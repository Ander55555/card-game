<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arcane Blitz — Online Card Duel</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#7c3aed;--muted:#94a3b8;--panel:#081023}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071025,#0b1228);color:#e6eef8}
    .app{max-width:1100px;margin:22px auto;padding:18px;border-radius:12px}
    header{display:flex;align-items:center;gap:12px}
    h1{font-size:20px;margin:0}
    .board{display:grid;grid-template-columns:1fr 340px;gap:18px;margin-top:14px}
    .play-area{background:var(--panel);padding:12px;border-radius:10px;min-height:520px}
    .sidebar{background:rgba(10,12,18,0.6);padding:12px;border-radius:10px}
    .zone{border-radius:8px;padding:8px;margin-bottom:10px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent)}
    .row{display:flex;gap:8px;align-items:center}
    .info{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .player{padding:10px;border-radius:8px}
    .life{font-weight:700;font-size:18px}
    .hand{display:flex;gap:8px;flex-wrap:wrap}
    .card{width:92px;height:128px;border-radius:8px;background:linear-gradient(180deg,#0b2136,#06202b);box-shadow:0 6px 18px rgba(4,6,12,0.6);padding:8px;display:flex;flex-direction:column;justify-content:space-between;cursor:pointer;user-select:none}
    .card.disabled{opacity:0.4;pointer-events:none;cursor:default;}
    .card .title{font-size:12px;font-weight:700}
    .card .flavor{font-size:11px;color:var(--muted)}
    .mini{font-size:12px;color:var(--muted)}
    .deck-slot{width:56px;height:80px;border-radius:6px;background:linear-gradient(180deg,#081423,#03122a);display:flex;align-items:center;justify-content:center;flex-direction:column}
    .center-board{display:flex;flex-direction:column;gap:10px;align-items:center;margin-top:14px}
    .log{height:120px;overflow:auto;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:8px;border-radius:8px}
    button{background:var(--accent);border:none;padding:8px 10px;border-radius:8px;color:white;font-weight:700;cursor:pointer}
    button.secondary{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04)}
    .controls{display:flex;flex-direction:column;gap:8px}
    .big{font-size:18px}
    .muted{color:var(--muted)}
    footer{margin-top:12px;color:var(--muted);font-size:13px}
    .disabled{opacity:0.45;pointer-events:none}
    .card-type{font-size:11px;padding:4px;border-radius:6px;background:rgba(255,255,255,0.02);display:inline-block}
    .hand .card.playable{outline:3px solid rgba(124,58,237,0.18)}
    .health-bar{height:10px;background:rgba(255,255,255,0.05);border-radius:8px;overflow:hidden}
    .health-fill{height:100%;background:linear-gradient(90deg,#10b981,#047857);width:100%}
    .small{font-size:13px}
    #opponentZone.active {
      border: 2px solid var(--accent);
      padding: 8px;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Arcane Blitz — Online Card Duel</h1>
    </header>

    <div class="board">
      <div class="play-area" id="playArea">
        <div class="zone player" id="opponentZone">
          <div class="info">
            <div>
              <div class="small">Opponent</div>
              <div class="life" id="oppLife">--</div>
            </div>
            <div>
              <div class="mini">Deck</div>
              <div id="oppDeckCount" class="mini">--</div>
            </div>
            <div>
              <div class="mini">Energy</div>
              <div id="oppEnergy" class="mini">--</div>
            </div>
          </div>
        </div>

        <div class="center-board">
          <div class="zone" id="battlefield">
            <div class="small">Battlefield (played cards & effects)</div>
            <div id="battleLog" style="margin-top:8px;min-height:70px"></div>
          </div>

          <div class="row">
            <div class="deck-slot" id="deckSlot">
              <div class="small">Deck</div>
              <div id="deckCount">--</div>
            </div>
            <div class="deck-slot" id="discardSlot">
              <div class="small">Discard</div>
              <div id="discardCount">0</div>
            </div>
          </div>

          <div class="zone" id="controls">
            <div class="row">
              <div class="muted">Turn:</div>
              <div id="turnIndicator" class="big">--</div>
              <div style="flex:1"></div>
              <button id="endTurnBtn" class="disabled">End Turn</button>
            </div>
            <div style="margin-top:10px" class="row">
              <div class="muted">Timer:</div>
              <div id="turnTimer" class="big">--</div>
              <div style="flex:1"></div>
              <button id="newGame" class="secondary disabled">New Game (Online Auto)</button>
            </div>
          </div>
        </div>

        <div class="zone player" id="playerZone" style="margin-top:18px">
          <div class="info">
            <div>
              <div class="small">You</div>
              <div class="life" id="playerLife">--</div>
            </div>
            <div>
              <div class="mini">Hand</div>
              <div id="handCount" class="mini">--</div>
            </div>
            <div>
              <div class="mini">Energy</div>
              <div id="playerEnergy" class="mini">--</div>
            </div>
          </div>

          <div style="margin-top:10px">
            <div class="small">Your Hand</div>
            <div id="hand" class="hand" style="margin-top:8px"></div>
          </div>
        </div>

      </div>

      <aside class="sidebar">
        <div class="zone">
          <div class="small">Card Legend</div>
          <div class="muted small" style="margin-top:6px">Cards are resolved immediately when played. Read the tooltip for effects.</div>
          <ul style="margin-top:8px;color:var(--muted);font-size:13px">
            <li><strong>Attack</strong> — Deal direct damage.</li>
            <li><strong>Block</strong> — Negate next incoming damage.</li>
            <li><strong>Heal</strong> — Restore life.</li>
            <li><strong>Utility</strong> — Draw, swap, multi-effect.</li>
          </ul>
        </div>

        <div class="zone">
          <div class="small">Game Log</div>
          <div id="log" class="log"></div>
        </div>

        <footer>
          Tip: rounds are quick — typical game finishes under 5 minutes. Click cards to play them on your turn.
        </footer>
      </aside>
    </div>
  </div>

<script>
  // --- CARD DEFINITIONS (JSON) ---
  const DEFAULT_DECK = [
    {"id":"Strike","type":"Attack","power":3,"text":"Deal 3 damage.","energyCost":1},
    {"id":"Quick Strike","type":"Attack","power":2,"text":"Deal 2 damage. (Fast)","energyCost":1},
    {"id":"Guard","type":"Block","text":"Negate next 3 damage.","block":3,"energyCost":1},
    {"id":"Shield Bash","type":"Attack","power":2,"text":"Deal 2 damage and apply 2 block to yourself.","selfBlock":2,"energyCost":2},
    {"id":"Heal","type":"Heal","power":3,"text":"Restore 3 life.","energyCost":1},
    {"id":"Adrenaline","type":"Utility","text":"Draw 2 cards, then discard 1.","draw":2,"discard":1,"energyCost":0},
    {"id":"Overload","type":"Attack","power":5,"text":"Deal 5 damage. Lose 2 life.","selfDamage":2,"energyCost":3},
    {"id":"Riposte","type":"Utility","text":"Next attack you receive will be returned for half damage.","riposte":true,"energyCost":1},
    {"id":"Siphon","type":"Attack","power":2,"text":"Deal 2 damage and heal for 2.","healOnDamage":2,"energyCost":2},
    {"id":"Insight","type":"Utility","text":"Look at top 3 cards and pick 1 to add to hand.","scry":3,"energyCost":1},
  ];

  // --- Game engine state ---
  let state = {
    deck:[], discard:[],
    player:{life:20,hand:[],block:0,riposte:false, energy:3, maxEnergy:3},
    opp:{life:20,hand:[],block:0,riposte:false, energy:3, maxEnergy:3},
    turn:'player', turnNumber:1, ai:false, timer:60
  };

  let playerId = null;
  let roomId = null;
  let socket = null;

  // --- Utility functions ---
  function log(text){
    const el = document.getElementById('log');
    el.innerHTML = (new Date()).toLocaleTimeString() + ' — ' + text + '\n' + el.innerHTML;
  }

  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      let j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
  }

  function cloneCard(card){return JSON.parse(JSON.stringify(card));}

  // --- Render functions ---
  function renderAll(){
    document.getElementById('playerLife').innerText = state.player.life;
    document.getElementById('oppLife').innerText = state.opp.life;
    document.getElementById('deckCount').innerText = state.deck.length;
    document.getElementById('discardCount').innerText = state.discard.length;
    document.getElementById('oppDeckCount').innerText = state.deck.length;
    document.getElementById('playerEnergy').innerText = state.player.energy;
    document.getElementById('oppEnergy').innerText = state.opp.energy;
    document.getElementById('turnIndicator').innerText = state.turn==='player'? 'Your Turn' : 'Opponent Turn';

    // Enable/disable end turn button
    const endBtn = document.getElementById('endTurnBtn');
    if(state.turn==='player'){
      endBtn.classList.remove('disabled');
      endBtn.onclick = () => endTurn();
    } else {
      endBtn.classList.add('disabled');
      endBtn.onclick = null;
    }

    // Render player hand
    const handDiv = document.getElementById('hand');
    handDiv.innerHTML = '';
    state.player.hand.forEach((c,i) => {
      const cardDiv = document.createElement('div');
      cardDiv.className = 'card';
      const cost = c.energyCost || 1;
      if(state.turn !== 'player' || state.player.energy < cost) cardDiv.classList.add('disabled');

      cardDiv.innerHTML = `<div><div class=title>${c.id} (${cost}⚡)</div><div class=card-type>${c.type}</div></div><div class=flavor>${c.text||''}</div>`;

      if(state.turn === 'player' && state.player.energy >= cost){
        cardDiv.onclick = () => playCard(state.player, state.opp, i);
      }

      handDiv.appendChild(cardDiv);
    });
  }

  function appendBattle(text){
    const el = document.getElementById('battleLog');
    const timestamped = (new Date()).toLocaleTimeString() + ' — ' + text;
    el.innerHTML = timestamped + '<br>' + el.innerHTML;
  }

  // --- Game logic ---
  function drawCard(player){
    if(state.deck.length === 0){
      state.deck = state.discard.splice(0);
      shuffle(state.deck);
    }
    if(state.deck.length > 0){
      const card = state.deck.pop();
      player.hand.push(card);
    }
  }

  // Simplified example of resolving a card play, can be expanded
  function resolveCard(card, player, opponent){
    appendBattle(`${player === state.player ? 'You' : 'Opponent'} played ${card.id}`);

    // Energy cost check removed for demo, assumed validated on client

    if(card.type === 'Attack'){
      let damage = card.power || 0;
      if(opponent.block > 0){
        const blocked = Math.min(opponent.block, damage);
        damage -= blocked;
        opponent.block -= blocked;
        appendBattle(`${opponent === state.player ? 'You' : 'Opponent'} blocked ${blocked} damage.`);
      }

      if(opponent.riposte && damage > 0){
        const ret = Math.floor(damage/2);
        appendBattle(`${opponent === state.player ? 'You' : 'Opponent'} ripostes for ${ret} damage!`);
        player.life -= ret;
        opponent.riposte = false;
      }

      if(damage > 0){
        opponent.life -= damage;
        appendBattle(`${opponent === state.player ? 'You' : 'Opponent'} took ${damage} damage.`);
      }

      if(card.healOnDamage){
        player.life += card.healOnDamage;
        appendBattle(`${player === state.player ? 'You' : 'Opponent'} healed for ${card.healOnDamage}.`);
      }

      if(card.selfDamage){
        player.life -= card.selfDamage;
        appendBattle(`${player === state.player ? 'You' : 'Opponent'} takes ${card.selfDamage} self damage.`);
      }

      if(card.selfBlock){
        player.block += card.selfBlock;
        appendBattle(`${player === state.player ? 'You' : 'Opponent'} gains ${card.selfBlock} block.`);
      }
    } else if(card.type === 'Block'){
      player.block += card.block || 0;
      appendBattle(`${player === state.player ? 'You' : 'Opponent'} gains ${card.block} block.`);
    } else if(card.type === 'Heal'){
      player.life += card.power || 0;
      appendBattle(`${player === state.player ? 'You' : 'Opponent'} heals ${card.power}.`);
    } else if(card.type === 'Utility'){
      if(card.riposte) {
        player.riposte = true;
        appendBattle(`${player === state.player ? 'You' : 'Opponent'} activates Riposte.`);
      }
      if(card.draw){
        for(let i=0;i<card.draw;i++) drawCard(player);
        appendBattle(`${player === state.player ? 'You' : 'Opponent'} draws ${card.draw} cards.`);
      }
      if(card.discard){
        for(let i=0;i<card.discard;i++){
          if(player.hand.length>0){
            const discarded = player.hand.pop();
            state.discard.push(discarded);
            appendBattle(`${player === state.player ? 'You' : 'Opponent'} discards ${discarded.id}.`);
          }
        }
      }
      // More effects can be added here
    }

    // Energy spent
    player.energy -= card.energyCost || 1;
  }

  // --- Online socket connection and matchmaking ---
  function setupSocket(){
    socket = new WebSocket('ws://localhost:8080');
    socket.onopen = () => {
      log('Connected to server, joining matchmaking...');
      socket.send(JSON.stringify({type:'join'}));
    };

    socket.onmessage = (evt) => {
      const data = JSON.parse(evt.data);
      if(data.type === 'joined'){
        playerId = data.playerId;
        roomId = data.roomId;
        log(`Joined room ${roomId} as ${playerId}`);
      }
      else if(data.type === 'startGame'){
        log(data.message);
        resetState();
        renderAll();
      }
      else if(data.type === 'playCard'){
        const isOpponent = data.playerId !== playerId;
        const cardIndex = data.cardIndex;
        const cardId = data.cardId;
        const playerObj = isOpponent ? state.opp : state.player;
        const opponentObj = isOpponent ? state.player : state.opp;

        // Remove card from player's hand
        if(playerObj.hand[cardIndex] && playerObj.hand[cardIndex].id === cardId){
          playerObj.hand.splice(cardIndex, 1);
          appendBattle(`${isOpponent ? 'Opponent' : 'You'} played ${cardId}`);
          resolveCard(cloneCard(DEFAULT_DECK.find(c => c.id === cardId)), playerObj, opponentObj);
          renderAll();
        }
      }
      else if(data.type === 'turnChange'){
        state.turn = (data.turn === 'player1' && playerId === 'player1') || (data.turn === 'player2' && playerId === 'player2') ? 'player' : 'opponent';
        log(`Turn changed: ${state.turn==='player'? 'Your Turn' : 'Opponent Turn'}`);
        if(state.turn === 'player'){
          // Refill energy, draw a card
          state.player.energy = state.player.maxEnergy;
          drawCard(state.player);
        }
        renderAll();
      }
      else if(data.type === 'error'){
        log(`Server error: ${data.message}`);
      }
    };

    socket.onerror = (err) => {
      log('WebSocket error');
      console.error(err);
    };

    socket.onclose = () => {
      log('Disconnected from server.');
    };
  }

  // --- Play card (client triggers server message) ---
  function playCard(playerOB, targetOB, cardIndex){
    if(state.turn !== 'player'){
      log('Not your turn!');
      return;
    }
    if(!socket || socket.readyState !== WebSocket.OPEN){
      log('Not connected to server.');
      return;
    }
    const card = state.player.hand[cardIndex];
    if(!card) return;
    if(card.energyCost > state.player.energy){
      log('Not enough energy.');
      return;
    }

    socket.send(JSON.stringify({
      type:'playCard',
      cardId: card.id,
      cardIndex: cardIndex
    }));
  }

  // --- End turn ---
  function endTurn(){
    if(state.turn !== 'player'){
      log('Not your turn!');
      return;
    }
    if(!socket || socket.readyState !== WebSocket.OPEN){
      log('Not connected to server.');
      return;
    }
    socket.send(JSON.stringify({type:'endTurn'}));
    state.turn = 'opponent';
    renderAll();
  }

  // --- Reset local game state ---
  function resetState(){
    state.deck = [];
    state.discard = [];
    state.player = {life:20,hand:[],block:0,riposte:false, energy:3, maxEnergy:3};
    state.opp = {life:20,hand:[],block:0,riposte:false, energy:3, maxEnergy:3};
    state.turn = 'player';
    state.turnNumber = 1;
    state.timer = 60;

    // Setup deck and deal hands
    for(let i=0;i<10;i++) state.deck.push(cloneCard(DEFAULT_DECK[i%DEFAULT_DECK.length]));
    shuffle(state.deck);
    for(let i=0;i<5;i++) drawCard(state.player);
    for(let i=0;i<5;i++) drawCard(state.opp);
  }

  document.getElementById('endTurnBtn').onclick = endTurn;
  document.getElementById('newGame').onclick = () => {
    if(socket && socket.readyState === WebSocket.OPEN){
      socket.send(JSON.stringify({type:'join'}));
    }
  };

  // Start socket connection on page load
  setupSocket();
  resetState();
  renderAll();

</script>
</body>
</html>
